함수
- '무엇'을 넣으면, '어떤 것'을 돌려주고 
메서드와 차이점 함수는 외부에 별도로 존재하고 메서드는 클래스안에 존재한다.

- 형식 = 매개변수1, 매개변수2로 입력하여 입력된 매개변수를 가공하고 처리하여 반환을 한다.

- plus = 매개변수를 두개를 입력받아 함수를 호출하여 v1,v2에 값을 넣어서 함수를 실행을 하며 result 값을 반환하여 plus 함수에 결과를 반환하여 hap에 반환된 값을 대입해준다.
         간략 표현 = 매개변수1,2에 입력된 매개변수를 더한값 300을 반환해준다.

- 지역변수 : 한정된 지역에서만 사용할 수 있다. (ex: a=10을 정의를 해주면 그 지역에서만 사용할 수 있으므로 그 외에 지역에서는 a의 값을 알 수가 없다.)
 
- 전역변수 : 프로그램 전체에서 사용할 수 있다. (ex: b=20을 정의를 해주면 프로그램 전체에서 사용할 수 있으므로 전체에서 b의 값을 알 수 있다.)

- a = 20
- a = 10
  print(a)를 하면 이때 a는 지역에 있는 변수이므로 지역변수를 의미한다.

- print(a)를 하면 이때 a는 전체 지역에 있는 변수이므로 전역변수를 의미한다.

- local(지역변수) = 특정 지역 범위에서만 영향을 주고 받을 수 있는 변수

- global(전역변수) = 파이썬 파일 전체 영역에서 사용 가능한 변수 (지역변수 인데 전역변수로 사용하고 싶을 때 사용)

함수의 반환값
- 반환값은 return문으로 반환되므로 리턴값
- 매개변수는 파라미터 라고한다.

반환값이 있는 함수
- 어떤 함수를 호출하여 함수를 실행하면 반환값이 있어서 그 값을 정해진 저장공간에 대입을 한다.

반환값이 없는 함수
- 어떤 함수를 호출하여 함수를 실행하면 반환값이 없어서 돌려줄 값이 없으므로 함수가 종료된다.

- pass = 코드는 필요하지만, 아무 작업도 하지 않기를 원할 때 사용


모듈
- 모듈의 종류 = 표준 - 파이썬에서 제공하는 모듈
               사용자 정의 - 직접 만들어서 사용하는 모듈
               서드 파티 - 파이썬이 아닌 외부나 단체에서 제공하는 모듈 ( 게임개발기능 = pygame, 윈도창을 제공 = pygtk, 데이터베이스 기능 = SQLAlchemy 

매개변수 전달
- 값에 의한 전달 = call by value
    일반 변수나 값을 전달할 때 함수에 동일한 크기의 별도의 메모리 공간이 확보되어 값이 복사되는 방식

- 참조에 의한 전달 = call by reference
    리스트를 매개변수로 전달하므로 주소가 전달되어 메모리 공간이 공유 되는 방식

내부함수
- lambda
    익명 함수라고 부르며 이름없는 함수로 일반적으로 함수를 한번만 사용하거나 함수를 인자로 전달해야 하는 경우 매우 유용하게 사용 ( 한줄로 가능하게 하는 함수)
- map
    시퀀스의 모든 요소에 함수를 적용한 결과를 반환


리스트/튜플/딕셔너리

- 정수, 문자열, 실수 등 서로 다른 데이터형도 하나로 묶을 수 있지만, 배열은 동일한 데이터형만 묶을 수 있다. 정수 배열은 정수로만 묶어서 사용 , 리스트로 정의해서 하나씩 변수로 사용

- 반복문과 사용시 값을 입력받아 i값이 0부터 3까지 4번 반복하고 i값이 변하게 한다.

- 리스트는 대괄호를 [] 생성하고 튜플은 소괄호 ()로 생성한다.

- 값을 수정할 수 없으며, 읽기만 가능해 읽기 전용 자료를 저장할 때 사용(튜플)

- 소괄호를 생략 가능, 항목이 하나인 튜플은 쉼표를 붙인다.

딕셔너리
- 해시, 연관배열(Associative Array)라고 한다.

- 중괄호로 {} 묶어서 구성, 키와 값으로 구성

- 딕셔너리[키]와 딕셔너리.get(키)는 결과가 같다.

- 딕셔너리[키]
  없는 키 호출하면 오류

- 딕셔너리.get(키)
  없는 키를 호출하면 아무것도 반환하지 않는다.

- 딕셔너리.items()
  튜플 형태로도 구할 수 있다.

- 키가 있으면 True, 없으면 False를 반환

- in을 사용해서 확인 가능, 키가 있는지 없는지

- 세트 = 키만 모아 놓은 딕셔너리의 특수 형태
    딕셔너리의 키는 중복되면 안되므로 세트에 들어 있는 값은 항상 유일하다.
    교집합,차집합,합집합,대칭 차집합을 구할 때 사용

- 얕은 복사
   = newList = oldList : 동일한 메모리 공간 공유

- 깊은 복사
    = newList = oldList[:] -> 메모리의 공간을 복사해서 새로 만든다.


리스트(list)

- 순서가 있고  접근할 때 인덱스를 사용하며 수정 가능한 자료형이기 때문에 요소를 추가하거나 삭제할 수 있다. 또한 중복된 요소를 가질 수 있다.

튜플(tuple)

- 리스트와 비슷하지만 수정 불가능한 자료형, 소괄호로 둘러싸여있고 여러개의 요소를 가질 수있다.
또한 요소에 접근할 때도 인덱스를 사용한다.

- 수정할 수 없기 때문에 요소를 추가하거나 삭제할 수 없다. 또한 중복된 요소를 가질 수 있다.

세트(set)

- 중복된 요소를 허용되지 않는 자료형, 중괄호로 둘러싸여 있고 여러 개의 요소를 가질 수 있다.

- 순서가없기 때문에 인덱스를 사용하여 요소에 접근할 수 없으며 수정 가능한 자료형이기 때문에 요소를 추가하거나 삭제할 수 있다. 또한 세트는 중복된 요소를 가질수 없다.


딕셔너리(dictionary)

- 키와 값의 쌍으로 이루어진 자료형, 중괄호로 둘러싸여 있으며 각각의 키와 값은 콜론(:)으로 구분

- 순서가 없기 때문에 인덱스를 사용하여 요소에 접근할 수 없으며 수정 가능한 자료형이므로 요소를 추가하거나 삭제할 수 있다. 또한 중복된 키를 가질수 없지만 중복된 값은 가질 수 있다.


Class 란? 

- 객체를 표현하기위한 문법, 체크박스,스크롤바 같은 트정한 개념이나 모양을 존재하는것을 객체

- 객체를 사용한 프로그래밍 언어를 객체지향 언어, 자주 사용되는 list,dict 등도 각자의 용도에 맞게     	만들어진 클래스

- 속성과 메소드로 구분되고 속성의 경우 매개변수를 받고 사용하기위한 값을 정의 , 메소드는 만들어	진 속성들을 이용해 어떤 행위를 하는 실행 코드

- 속성은 인스턴스를 생성할때 호출되는 특별한 메소드이며  self.속성값으로 할당한다.

-인스턴스 속성은 self.속성을 썻다면, 클래스 속성은 클래스명.속성 을 사용 한다. 

- 속성 : Class안에서 사용되는 변수 , 속성은 Class안으로 들어온 값을 저장하고 상태를 관리한다.

- 메서드 : Class안에서 사용되는 함수, 첫번째 인자로 자기자신을 받는다. self라는 변수를 첫번째 인	자의 자리에 사용

- 다형성 : 서로 다른 객체가 특정 유형에 적합한 방식으로 동일한 메서드를 호출에 응답할 수 있는 		기능,  단일인터페이스를 사용하여 다양한 유형의 객체를 표현하며 코드의 유연성과 확장성 향상

- 종종 메서드 재정의(하위 클래스가 부모 클래스에서 상속된 메서드에 대한 새로운 구현을 제공하는 		것)를 통해 달성


- 캡슐화 : 데이터(속성)와 데이터를 조작하는 연산(메서드)을 단일 단위인 클래스 안에 묶는 개념
	객체의 내부 상태에 대한 엑세스를 제한하여 외부 간섭으로부터 객체를 보호, 이중 밑줄 접두		사로 표시되는 비공개 속성 및 메서드를 사용하여 캡슐화를 구현


- 어트리뷰트(attributes) : 객체와 연관된 변수, 해당 인스턴스에 특정한 데이터를 저장하는데 사용	된다. Person 클래스에는 name과 age라는 두가지 속성이 있다.

- 생성자 : 객체가 인스턴스화될 때 호출되는 특수 메서드, 생성자의 이름은 __init__ 이며  이 함수는 	주어진 인수를 사용하여 객체의 속성을 초기화한다.

- 상위 개념이자 큰 틀이고, 설계도

- 클래스 변수 ( 정적 멤버 변수) = 모든 인스턴스의 클래스와 공유되는 변수의 사본이 하나만 있는 경우

- 구조체 : 클래스와 유사하지만, 주로 데이터를 저장하기 위한 용도로 사용


Class 의 특징

- 모든 클래스는 기본적으로 object 클래스를 상속받고 있다.

- 파이썬의 모든 자료형은 사실 클래스다.

- 내부 메소드를 인스턴스 메소드(클래스를 통해 생성한 인스턴스에서 호출) 
			 클래스 메소드(인스턴스 대신 클래스 자체에서 호출 
			 스태틱 메소드(클래스 메소드처럼 클래스에서 바로 호출할  수 있는 메소드)로 구분 가능

- 함수가 점차적으로 늘어 나게 된다면 무슨 역할을 하는지 의미를 파악하기 어려워지므로, 클래스를 통해 메	소드를 구현하게 되면, 비슷한 역할을 하는 것을 한 곳에  모을 수 있게 된다.  재사용이 가능하다는 것이 	큰 장점

- 클래스 정의 , 생성자, 클래스와 인스턴스 변수, 메서드(self) , 상속, 다형성, 캡슐화, 클래스메서드와 정적 메서드,메타클래스(클래스를 생성하는 클래스), 특수 메서드 (str,repr,eq,len 등)이 있다.

- 클래스 메서드는 클래스 자체를 인자로 받으며, 정적 메서드는 인자를 받지 않는다.

- 캡슐화 = 접근 제한자 (public, private, protected)로 구현

-  추상화(abstraction) =  객체의 공통적인 속성과 기능을 추출하여 정의하는것 , 실제로 존재하는 객체들을 프로그램으로 만들기 위한 공통적인 특성을 파악해서 필요없는 특성을 제거하는 과정



Thread 사용 방법

- 하나의 목표를 가진 프로그램을 수행 할때, 독립적으로 운영되는 작업


- 잠시 정차하여 지도를 보는 방법, 길을 잘아는 친구에게 전화를 걸어 물어보는 방법, 내비게이션이 안내해주는 길을 따라가는 방법


- 스레딩을 사용하기 위해서는 'threading' 모듈을 import해야 한다.

- 장점 = 1.병렬로 작업을 수행하여 프로그램의 성능을 향상시킬 수 있다.
	      2.여러 작업을 동시에 처리할 수 있어 시간을 절약할 수 있다.
	      3.다른 스레드에서 실행 중인 작업이 블로킹되지 않고 동시에 실행될 수 있다.


- 단점 = 1. 스레드 간의 동기화 문제가 발생할 수 있습니다. 여러 스레드가 동시에 동일한 자원에 접근하면서 		      	   	  충돌이 발생할 수 있다.
              
2.스레드를 관리하는 것이 복잡할 수 있으며  스레드 간의 우선순위, 상태 등을 고려해야 한다.
             
 3.스레드를 사용하면 오버헤드가 발생할 수 있습니다. 스레드를 생성하고 관리하는 데에는 시스템 자원이 소		         모된다.

- 보통 외부의 이벤트를 오래동안 기다려야(I/O bound) 하는 작업에 적용하면 효과적이다. 하지만 많은 CPU연산을 필요로 하는 작업에는 Thread 보단 multiprocessing이 어울린다.



객체지향 프로그래밍의 장점

- 함수와 프로시저 대신 객체라는 개념을 중심으로 코드를 구성하는데 중심을 둔 프로그래밍 패러다임,
객체는 클래스의 인스턴스이며, 클래스는 객체의 속성과 메서드(동작)를 정의하는 청사진 , 파이썬은 여러 패러다임 중에서도 객체 지향 프로그래밍을 지원하는 다중 패러다임 언어이다.

-1. 재사용성
상속을 통해 프로그래밍시 코드의 재사용을 높일 수 있음.

 

2. 생산성 향상
잘 설계된 클래스를 만들어서 독립적인 객체를 사용함으로써 개발의 생산성을 향상시킬 수 있음.

 

3. 자연적인 모델링
우리 일상생활의 모습의 구조가 객체에 자연스럽게 녹아들어 있기 때문에 생각하고 있는 것을 그대로 자연스럽게 구현할 수 있다.

 

4. 유지보수의 우수성
프로그램 수정시 추가, 수정을 하더라도 캡슐화를 통해 주변 영향이 적기때문에 유지보수가 쉬워서 매우 경제적이라할
수 있다.


단점

-1. 개발속도가 느린점
객체가 처리하려는 것에 대한 정확한 이해가 필요하기에 설계단계부터 많은 시간이 소모 된다.

 

2. 실행속도가 느린점

객체지향언어는 대체적으로 실행속도가 느리다.

 

3. 코딩난이도 상승
다중 상속이 지원되는 C++ 같은 경우에 너무 복잡해져 코딩의 난이도가 상승할 수 있다.




10문제 4지선다 





from turtle import Turtle
from turtle import *
import random

t = Turtle()
t.screen.title('Turtle Name')
t.screen.bgcolor("white")
t.shape('turtle')
t.pensize(5)
t.speed(2)
rgb = ['blue','red','black','yellow','green'] 

def turtle_move(posi):

    for _ in range(posi):
        x = random.randint(-400,400)
        y = random.randint(-400,400)
        t.pencolor(random.choice(rgb))
        t.goto(x,y)
        t.fillcolor(random.choice(rgb))

turtle_move(10)
t.screen.mainloop()




aa = [3,2,1,2,3,3,2,3,4,5,2,3,3,4,2]
bb = aa.copy()

print("aa의 리스트를 bb로 복사 : %s" % bb)

for i in range(1, len(bb)):
    if bb.count(bb[i-1]) > bb.count(bb[i]):
        bb[i] = bb[i-1]
        c = bb[i]

print("aa에서 가장 많이 있는 수 : %d" % c)
